#!/usr/bin/env nix-shell
#!nix-shell -i python3 -p python3
# vim: ft=python
import shlex
from dataclasses import dataclass
from enum import Enum
from pathlib import Path
from typing import Iterator


USER = "multisn8"
MOUNTS_PATH = f"/home/{USER}/zukunftslosigkeit/configs/nixos/elusive/mounts"
QEMU_PROJECT_PATH_NAME = "opt/elusive/project_path"


class Access(Enum):
    ReadOnly = 1
    ReadWrite = 2

    def parse(source: str):
        match source:
            case "ro":
                return Access.ReadOnly
            case "rw":
                return Access.ReadWrite


@dataclass
class Mount:
    access: Access
    path: str
    tag: str

    def parse(line: str):
        parts = line.split()
        return Mount(
            access=Access.parse(parts[0]),
            path=parts[1],
            tag=parts[2],
        )


def parse_mounts(mounts_path=MOUNTS_PATH) -> Iterator[Mount]:
    def should_ignore_line(line: str) -> bool:
        line = line.strip()
        return line.startswith("#") or not line

    lines = Path(mounts_path).read_text().splitlines()
    relevant_lines = filter(lambda line: not should_ignore_line(line), lines)

    return map(
        Mount.parse,
        relevant_lines,
    )


def format_as_qemu_args(project_path: str, mounts: list[Mount]) -> list[str]:
    args = [
        "-fw_cfg",
        f"name={QEMU_PROJECT_PATH_NAME},string={expand_user(project_path)}",
    ]

    for mount in mounts:
        path = expand_user(expand_project_path("$project_path", project_path))
        mount_opts = [
            "local",
            "security_model=mapped-xattr",
            f"mount-tag={mount.tag}",
            f"path={path}",
        ]

        if mount.access == Access.ReadOnly:
            mount_opts.append("readonly=on")

        args += ["-virtfs", ",".join(mount_opts)]

    return args


def format_as_guest_mount_cmds(mounts: list[Mount]) -> list[str]:
    """
    Formats the given mounts as all commands that would be needed in order to
    mount all shared folders on the guest. The commands need to be run through a shell.
    """
    project_path = (
        f"$(cat /sys/firmware/qemu_fw_cfg/by_name/{QEMU_PROJECT_PATH_NAME}/raw)"
    )

    cmds = [
        shlex.join(
            [
                "mount",
                "-t",
                "9p",
                "-o",
                "trans=virtio,version=9p2000.L,msize",
                mount.tag,
            ]
        )
        + " "
        # great possibility for shell injection
        # guess the mount path is trusted for now
        + expand_user(expand_project_path(mount.path, project_path))
        for mount in mounts
    ]

    return cmds


def expand_user(path: str, user=USER):
    return path.replace("~", f"/home/{user}")


def expand_project_path(path: str, project_path: str):
    return path.replace("$project_path", project_path)


import pprint

print(format_as_guest_mount_cmds(parse_mounts()))
