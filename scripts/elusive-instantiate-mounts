#!/usr/bin/env nix-shell
#!nix-shell -i python3 -p python3
# vim: ft=python
import argparse
import shlex
import sys
from dataclasses import dataclass
from enum import Enum
from pathlib import Path
from typing import Iterator


USER = "multisn8"
MOUNTS_PATH = f"/home/{USER}/zukunftslosigkeit/configs/nixos/elusive/mounts"
QEMU_PROJECT_PATH_NAME = "opt/elusive/project_path"


def main():
    args = parse_args()
    mounts = parse_mounts(args.mounts)

    result = args.callback(args, mounts)
    sys.stdout.write(result)
    sys.stdout.flush()


def parse_args():
    parser = argparse.ArgumentParser()
    parser.add_argument("--mounts", default=MOUNTS_PATH)

    subparsers = parser.add_subparsers(required=True)

    parser_host = subparsers.add_parser("host")
    parser_host.add_argument("project_path")
    parser_host.set_defaults(callback=host)

    parser_guest = subparsers.add_parser("guest")
    parser_guest.set_defaults(callback=guest)

    return parser.parse_args()


def host(args, mounts) -> str:
    return shlex.join(format_as_host_qemu_args(args.project_path, mounts))


def guest(args, mounts) -> str:
    return "\n".join(format_as_guest_mount_cmds(mounts)) + "\n"


class Access(Enum):
    ReadOnly = 1
    ReadWrite = 2

    def parse(source: str):
        match source:
            case "ro":
                return Access.ReadOnly
            case "rw":
                return Access.ReadWrite


@dataclass
class Mount:
    access: Access
    path: str
    tag: str

    def parse(line: str):
        parts = line.split()
        return Mount(
            access=Access.parse(parts[0]),
            path=parts[1],
            tag=parts[2],
        )


def parse_mounts(mounts_path=MOUNTS_PATH) -> Iterator[Mount]:
    def should_ignore_line(line: str) -> bool:
        line = line.strip()
        return line.startswith("#") or not line

    lines = Path(mounts_path).read_text().splitlines()
    relevant_lines = filter(lambda line: not should_ignore_line(line), lines)

    return map(
        Mount.parse,
        relevant_lines,
    )


def format_as_host_qemu_args(project_path: str, mounts: list[Mount]) -> list[str]:
    args = [
        "-fw_cfg",
        f"name={QEMU_PROJECT_PATH_NAME},string={expand_user(project_path)}",
    ]

    for mount in mounts:
        path = expand_user(expand_project_path(mount.path, project_path))
        mount_opts = [
            "local",
            "security_model=mapped-xattr",
            f"mount_tag={mount.tag}",
            f"path={path}",
        ]

        if mount.access == Access.ReadOnly:
            mount_opts.append("readonly=on")

        args += ["-virtfs", ",".join(mount_opts)]

    return args


def format_as_guest_mount_cmds(mounts: list[Mount]) -> list[str]:
    """
    Formats the given mounts as all commands that would be needed in order to
    mount all shared folders on the guest. The commands need to be run through a shell.
    """
    project_path = (
        f"$(cat /sys/firmware/qemu_fw_cfg/by_name/{QEMU_PROJECT_PATH_NAME}/raw)"
    )

    cmds = [
        shlex.join(
            [
                "/run/wrappers/bin/mount",
                "--mkdir",
                "-t",
                "9p",
                "-o",
                "nosuid,nodev,exec,trans=virtio,version=9p2000.L,msize=32M",
                mount.tag,
            ]
        )
        + " "
        # great possibility for shell injection
        # guess the mount path is trusted for now
        + expand_user(expand_project_path(mount.path, project_path))
        for mount in mounts
    ]

    return cmds


def expand_user(path: str, user=USER):
    return path.replace("~", f"/home/{user}")


def expand_project_path(path: str, project_path: str):
    return path.replace("$project_path", project_path)


if __name__ == "__main__":
    main()
