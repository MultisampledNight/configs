#!/usr/bin/env python3
# vim: ft=python
import argparse
import os
import shutil
import sys
from datetime import datetime
from pathlib import Path


HOME_DIR = "/home/multisn8"
ARCHIVE_DIR = "~/_archive"
# None means "generate it on-the-fly"
TIME_TAG = None


def archive(subject_path, home_dir=HOME_DIR, archive_dir=ARCHIVE_DIR, time_tag=TIME_TAG) -> int:
    """
    Moves `subject_path` under `backup_dir` after the pattern:

    if <time_tag> is None:
        subject_path = <home_dir>/A/B/C.txt
        => <backup_dir>/backup/<TIMESTAMP>/A/B/C.txt
    else:
        subject_path = <home_dir>/A/B/C.txt
        => <backup_dir>/<time_tag>/A/B/C.txt

    Essentially generating a timestamp if `time_tag` is None, and archiving
    `subject_path` while preserving its subdirectory under `home_path`.
    Does nothing if `subject_path` does not exist.
    """
    if not Path(subject_path).exists():
        return

    if time_tag is None:
        time_tag = Path("backup") / datetime.now().isoformat()

    archive_dir = Path(str(archive_dir).replace("~", HOME_DIR))
    archive_dir /= time_tag

    subject_path = Path(subject_path).resolve()
    try:
        rel_path = subject_path.relative_to(home_dir)
    except ValueError:
        # not a subpath of home_dir
        # in that case just archive it based on its relativeness from root
        rel_path = subject_path.relative_to("/")
        
    target_path = archive_dir / rel_path

    try:
        target_path.parent.mkdir(parents=True, exist_ok=True)
        shutil.move(subject_path, target_path)
    except PermissionError:
        print(
            f"Skipping {subject_path} due to missing perms",
            file=sys.stderr,
        )
        return 1

    return 0


def parse_args():
    parser = argparse.ArgumentParser(
        description="quick and dirty archival, ignoring nonexistent dirs"
    )
    parser.add_argument("path")
    parser.add_argument("--home-dir", default=HOME_DIR)
    parser.add_argument("--archive-dir", default=ARCHIVE_DIR)
    parser.add_argument("--time-tag", default=TIME_TAG)
    return parser.parse_args()


def main():
    args = vars(parse_args())
    exit_code = archive(args.pop("path"), **args)
    sys.exit(exit_code)


if __name__ == "__main__":
    main()
