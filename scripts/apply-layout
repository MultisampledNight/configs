#!/usr/bin/env python
from dataclasses import dataclass
from enum import IntEnum
from socket import gethostname
from subprocess import run
from typing import Iterator, Optional


@dataclass
class Screen:
    x: int = 0
    y: int = 0
    scale: Optional[int] = None

    def sway_commands(self, name: str) -> Iterator[list[str]]:
        cmds = []
        name = name.replace("_", "-")

        cmds.append(["output", name, "position", self.x, self.y])
        if self.scale is not None:
            cmds.append(["output", name, "scale", self.scale])

        return map(
            lambda cmd: list(map(str, cmd)),
            cmds,
        )


@dataclass
class Layout:
    eDP_1: Optional[Screen] = None
    DP_1: Optional[Screen] = None
    DP_3: Optional[Screen] = None
    HDMI_A_1: Optional[Screen] = None

    def sway_commands(self) -> list[list[str]]:
        cmds = []

        for name, config in self.__dict__.items():
            if config is None:
                continue

            cmds.extend(config.sway_commands(name))

        return cmds


# layout syntax in ABNF:
#
# layout = screen *(sp "+" sp screen)
# screen =           connector
#         [sp "@" sp resolution]
#         [sp ":" sp scale]
#         [sp "/" sp pos]
# sp = *(WSP / CR / LF)
#
# connector = plug-type sp [number]
# plug-type = "edp" / "hdmi" / "dp"
# number = 1*DIGIT
#
# resolution = "720p" / "1080p" / "1200p" / "4k"
#
# scale = 1*DIGIT ["." 1*DIGIT]
#
# pos =   hori
#       / vert
#       / hori sp "," sp vert
#       / vert sp "," sp hori
# hori = "l" ["eft"]
#      / "c" ["enter"]
#      / "r" ["ight"]
# vert = "t" ["op"]
#      / "h" ["orizon"]
#      / "b" ["ot" ["tom"]]
#
# notes:
# - connector number defaults to "1"
# - resolution defaults to "1080p"
# - scale defaults to "1" if under 4k, otherwise "2"
# - pos
#   - defaults to "right,top"
#   - specifies on where to place the current screen
#     when viewing the entire bounding box
#     of all layout until now
#
# yes this will be actually automatized some day
# yes i will rewrite this in rust and make it non-hardcoded
LAYOUTS = {
    "hdmi + edp/bottom,center": Layout(
        eDP_1=Screen(x=390, y=1080), HDMI_A_1=Screen(scale=1)
    ),
    "hdmi@1200p + edp/bottom,center": Layout(
        eDP_1=Screen(x=390, y=1200), HDMI_A_1=Screen(scale=1)
    ),
    "hdmi@4k + edp/bottom,center": Layout(
        eDP_1=Screen(x=396, y=1080),
        HDMI_A_1=Screen(scale=2),
    ),
    "dp@1440p + edp/bottom,center": Layout(
        eDP_1=Screen(x=152, y=1440),
        DP_1=Screen(scale=1.25),
    ),
    "dp3@1200p + hdmi/right,bottom": Layout(
        DP_3=Screen(),
        HDMI_A_1=Screen(x=1920, y=120)
    ),
}

MACHINES = {
    "destined": "dp@1440p + edp/bottom,center",
    "overloaded": "dp3@1200p + hdmi/right,bottom",
}


def apply_layout(layout: Optional[Layout | str] = None):
    if layout is None:
        layout = MACHINES[gethostname()]

    if isinstance(layout, str):
        layout = LAYOUTS[layout]

    for cmd in layout.sway_commands():
        run(["swaymsg"] + cmd)


if __name__ == "__main__":
    apply_layout()
